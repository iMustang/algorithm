package datastructure;

/**
 * HashTable
 * description:讲解数据结构中的哈希表
 */
public class HashTable {
	/**
	 * 1. 散列函数的构造方法：
	 *     直接定址法：f(key)=a*key+b,(a、b为常数)，需要事先知道关键字的分布情况，适合查找表较小且连续的情况。
	 *     数字分析法：如手机号取后4位作为哈希值，或再对这些数字进行一些变换。
	 *     平方取中法：如1234，平方后1522756，取中间3位227作为哈希值。适合用于不知道关键字的分布，位数又不是很大的情况。
	 *     折叠法：将关键字从左到右分割成位数相等的几部分，然后这几部分叠加求和，并按散列表表长，取后几位作为散列地址。事先不需要知道关键字的分布，适合关键字位数较多的情况。
	 *     除留余数法：f(key)=key mod p，(p<=m)，p为小于等于表长的最小质数或不包含小于20质因子的合数。
	 *     随机数法：f(key)=random(key)，适合关键字长度不等时。
	 *
	 * f(key1)=f(key2)，这种现象叫冲突，key1、key2称为这个散列函数的同义词。
	 *
	 * 2. 处理散列冲突的方法：
	 *     开放地址法：一旦发生了冲突，就寻找下一个空的散列地址。只要散列表足够大，空的散列地址总能找到。
	 *                会产生本来不是同义词的两个关键字，争夺同一地址的情况，这种现象叫堆积。
	 *         线性探测法：fi(key)=((f(key)+di) mod m，(di=1,2,3,...m-1)
	 *         二次探测法：fi(key)=((f(key)+di) mod m，(di=1^2,-1^2,2^2,-2^2,...q^2,-q^2,q<=m/2)
	 *         随机探测法：fi(key)=((f(key)+di) mod m，(di是一个随机数列)
     *         再散列函数法：
	 *         fi(key)=RHi(key)，(i=1,2,...key)，RHi是不同的散列函数，即，发生散列冲突时，换一个散列函数。
	 *     链地址法：
	 *         将同义词存放在单链表中。
	 *     公共溢出区法：
	 *         将冲突的关键字存储到溢出表中。适合对基本表而言，有冲突的数据很少的情况。
	 *
	 */
}
